<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>命运空间 · Fate</title>
  <meta name="color-scheme" content="dark" />
  <style>
    :root{
      --bg-0: #0a0b10;
      --bg-1: #0b0e18;
      --ink: #EDEFF6;
      --ink-dim: #BFC6D9;
      --card-border: rgba(255,255,255,0.08);
      --glow: 255, 185, 245;
      --accent: #C77DFF;
      --accent-2: #7DE1FF;
    }

    *{ box-sizing: border-box; }
    html, body{
      height: 100%;
      margin: 0;
      color: var(--ink);
      font-family: ui-serif, Georgia, "Songti SC", "Noto Serif CJK SC", serif;
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(255,255,255,0.04), transparent 60%),
        radial-gradient(1200px 800px at 80% 90%, rgba(255,255,255,0.03), transparent 60%),
        linear-gradient(135deg, var(--bg-0), var(--bg-1) 40%, var(--bg-1) 60%, var(--bg-0));
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
    }

    /* 载入帷幕：浓雾完全覆盖，数据就绪后散开并移除 */
    .veil{
      position: fixed; inset: -10%;
      z-index: 1000; pointer-events: none; display: grid; place-items: center;
      background: radial-gradient(80% 80% at 50% 50%, rgba(20,22,34,0.2), rgba(10,12,20,0.75) 50%, rgba(5,6,12,0.92));
    }
    .veil .fog{
      position: absolute; width: 72vw; height: 165vh; filter: blur(36px) saturate(120%);
      opacity: .96; mix-blend-mode: screen;
      background:
        radial-gradient(40% 60% at 30% 30%, rgba(255,115,156,0.28), transparent 60%),
        radial-gradient(40% 60% at 70% 70%, rgba(107,154,255,0.26), transparent 60%);
    }
    .veil .fog.l{ transform: translate3d(-8%, 6%, 0) rotate(-26deg); }
    .veil .fog.r{
      transform: translate3d(8%, -6%, 0) rotate(26deg);
      background:
        radial-gradient(40% 60% at 70% 30%, rgba(107,154,255,0.28), transparent 60%),
        radial-gradient(40% 60% at 30% 70%, rgba(143,255,221,0.24), transparent 60%);
    }
    .veil.disperse .fog.l{ animation: disperseL 1.8s ease forwards; }
    .veil.disperse .fog.r{ animation: disperseR 1.8s ease forwards; }
    @keyframes disperseL{
      0% { opacity:.96; transform: translate3d(-8%,6%,0) rotate(-26deg) scale(1.05) }
      100%{ opacity:0;  transform: translate3d(-60%,-25%,0) rotate(-30deg) scale(1.08) }
    }
    @keyframes disperseR{
      0% { opacity:.96; transform: translate3d(8%,-6%,0) rotate(26deg) scale(1.05) }
      100%{ opacity:0;  transform: translate3d(60%,25%,0) rotate(30deg) scale(1.08) }
    }

    /* 抽题时全屏眩晕（无文字，仅视觉覆盖 3s） */
    .vortex{
      position: fixed; inset: 0; z-index: 900; pointer-events: none;
      opacity: 0; transform: scale(1);
    }
    .vortex.show{
      animation: vortexFade 3s ease forwards;
    }
    /* 旋转放射条 */
    .vortex::before{
      content:""; position: absolute; inset: -25%;
      background:
        conic-gradient(from 0turn,
          rgba(255,255,255,0.06) 0deg, rgba(255,255,255,0.0) 12deg,
          rgba(255,255,255,0.06) 24deg, rgba(255,255,255,0.0) 36deg,
          rgba(255,255,255,0.06) 48deg, rgba(255,255,255,0.0) 60deg,
          rgba(255,255,255,0.06) 72deg, rgba(255,255,255,0.0) 84deg,
          rgba(255,255,255,0.06) 96deg, rgba(255,255,255,0.0) 108deg,
          rgba(255,255,255,0.06) 120deg, rgba(255,255,255,0.0) 132deg,
          rgba(255,255,255,0.06) 144deg, rgba(255,255,255,0.0) 156deg,
          rgba(255,255,255,0.06) 168deg, rgba(255,255,255,0.0) 180deg,
          rgba(255,255,255,0.06) 192deg, rgba(255,255,255,0.0) 204deg,
          rgba(255,255,255,0.06) 216deg, rgba(255,255,255,0.0) 228deg,
          rgba(255,255,255,0.06) 240deg, rgba(255,255,255,0.0) 252deg,
          rgba(255,255,255,0.06) 264deg, rgba(255,255,255,0.0) 276deg,
          rgba(255,255,255,0.06) 288deg, rgba(255,255,255,0.0) 300deg,
          rgba(255,255,255,0.06) 312deg, rgba(255,255,255,0.0) 324deg,
          rgba(255,255,255,0.06) 336deg, rgba(255,255,255,0.0) 348deg
        );
      filter: blur(10px) saturate(140%);
      border-radius: 50%;
      opacity: 0.85;
    }
    /* 暗角与中心微光 */
    .vortex::after{
      content:""; position: absolute; inset: 0;
      background:
        radial-gradient(60% 60% at 50% 50%, rgba(255,255,255,0.06), rgba(255,255,255,0) 35%),
        radial-gradient(120% 120% at 50% 50%, rgba(0,0,0,0) 40%, rgba(0,0,0,0.45) 75%, rgba(0,0,0,0.65) 100%);
      mix-blend-mode: normal;
    }
    @keyframes vortexFade{
      0%   { opacity: 0; transform: scale(1) rotate(0deg) }
      10%  { opacity: .95 }
      60%  { opacity: .92 }
      100% { opacity: 0; transform: scale(1.06) rotate(360deg) }
    }
    /* 让放射条也旋转缩放（继承容器动画的同时轻微相反向） */
    .vortex.show::before{ animation: spinZoom 3s cubic-bezier(.2,.9,.2,1) forwards; }
    @keyframes spinZoom{
      0%   { transform: rotate(0deg) scale(1) }
      50%  { transform: rotate(-180deg) scale(1.04) }
      100% { transform: rotate(-360deg) scale(1.08) }
    }

    /* 返回（更隐蔽） */
    .home{
      position: fixed;
      top: max(10px, env(safe-area-inset-top));
      left: max(10px, env(safe-area-inset-left));
      width: 34px; height: 34px; border-radius: 10px;
      display: grid; place-items: center;
      color: var(--ink);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
      border: 1px solid rgba(255,255,255,0.06);
      text-decoration: none;
      backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
      transition: opacity .2s ease, transform .2s ease, border-color .2s ease;
      z-index: 10; opacity: .18;
    }
    .home:hover{ opacity:.85; transform: translateY(-1px); border-color: rgba(255,255,255,0.18); }
    .home .arrow{
      width: 14px; height: 14px; display: inline-block;
      border: 2px solid currentColor; border-right: none; border-top: none;
      transform: rotate(45deg); opacity: .9;
    }
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    /* 舞台与卡片 */
    .stage{ position: relative; height: 100%; display: grid; place-items: center; padding: 12vh 5vw 18vh; }
    .card{
      position: relative; width: min(980px, 88vw); min-height: 180px;
      padding: clamp(18px, 2.8vw, 36px) clamp(20px, 3.2vw, 48px);
      border-radius: 24px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)) border-box,
        linear-gradient(145deg, rgba(255,255,255,0.18), transparent 40%) border-box;
      border: 1px solid var(--card-border);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.08),
        0 30px 80px rgba(0,0,0,0.45),
        0 20px 60px rgba(72, 28, 120, 0.25);
      isolation: isolate; overflow: hidden;
    }
    .card::before, .card::after{
      content:""; position: absolute; inset: -40%;
      background:
        radial-gradient(35% 20% at 20% 40%, rgba(var(--glow),0.06), transparent 60%),
        radial-gradient(30% 25% at 80% 60%, rgba(125, 225, 255, 0.06), transparent 60%);
      filter: blur(50px); transform: rotate(12deg);
      animation: drift 18s ease-in-out infinite; pointer-events: none;
    }
    .card::after{ animation-duration: 26s; animation-direction: reverse; opacity: 0.7; }
    @keyframes drift{
      0%,100%{ transform: translate3d(0,0,0) rotate(12deg) }
      50%{ transform: translate3d(-2%,1.2%,0) rotate(10deg) }
    }

    .q{
      position: relative; font-size: clamp(20px, 3.4vw, 40px);
      line-height: 1.38; letter-spacing: 0.02em; color: var(--ink);
      text-wrap: balance; text-shadow: 0 1px 0 rgba(0,0,0,0.35), 0 10px 30px rgba(0,0,0,0.25);
      min-height: 2.8em; display: flex; align-items: center;
      transition: filter .4s ease, opacity .4s ease;
    }
    .q.dim{ color: var(--ink-dim); filter: blur(1px); opacity: .9; }
    .q.obscured{ filter: blur(6px); opacity: .2; }

    .card.tremor{ animation: tremor 360ms cubic-bezier(.2,.9,.25,1.1); }
    @keyframes tremor{
      0% { transform: translateX(0) }
      20%{ transform: translateX(-1px) }
      40%{ transform: translateX(1px) }
      60%{ transform: translateX(-0.6px) }
      80%{ transform: translateX(0.6px) }
      100%{ transform: translateX(0) }
    }
    .card.glow{
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.08),
        0 30px 80px rgba(0,0,0,0.45),
        0 0 0 1px rgba(199,125,255,0.14),
        0 0 50px rgba(199,125,255,0.22),
        0 0 120px rgba(125,225,255,0.14);
      transition: box-shadow 560ms ease;
    }

    /* 底部符印按钮 */
    .sigil-wrap{
      position: fixed; left: 50%;
      bottom: max(24px, calc(env(safe-area-inset-bottom) + 16px));
      transform: translateX(-50%); z-index: 9; display: grid; place-items: center;
    }
    .sigil{
      --size: clamp(64px, 9.5vw, 92px);
      width: var(--size); height: var(--size);
      border-radius: 999px; border: 1px solid rgba(255,255,255,0.12);
      background:
        radial-gradient(60% 60% at 50% 40%, rgba(255,255,255,0.12), rgba(255,255,255,0.02)),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 6px 30px rgba(0,0,0,0.45), inset 0 8px 18px rgba(255,255,255,0.06);
      display: grid; place-items: center; cursor: pointer;
      transition: transform .2s ease, box-shadow .25s ease, background .3s ease;
      position: relative; overflow: hidden;
    }
    .sigil::before{
      content:""; position: absolute; inset: -40%;
      background: radial-gradient(50% 50% at 50% 50%, rgba(var(--glow),0.14), transparent 60%);
      filter: blur(40px); opacity: 0.6; animation: breathe 3.6s ease-in-out infinite;
    }
    @keyframes breathe{ 0%,100%{ transform: scale(1); opacity: .5 } 50%{ transform: scale(1.05); opacity: .8 } }
    .sigil:hover{ transform: translateY(-2px); box-shadow: 0 10px 40px rgba(0,0,0,0.55), 0 0 24px rgba(199,125,255,0.18), 0 0 60px rgba(125,225,255,0.12); }
    .sigil:active{ transform: translateY(0); }
    .sigil svg{ width: 64%; height: 64%; display: block; }
    .ring{ stroke-dasharray: 2 6; animation: ring 6s linear infinite; opacity: 0.85; transform-origin: 50 50; }
    @keyframes ring{ to{ transform: rotate(360deg) } }
    .sigil.loading{ animation: pulse 1.6s ease-in-out infinite; pointer-events: none; }
    @keyframes pulse{
      0%,100%{ box-shadow: 0 6px 30px rgba(0,0,0,0.45), 0 0 18px rgba(199,125,255,0.12), 0 0 48px rgba(125,225,255,0.08) }
      50%{ box-shadow: 0 6px 30px rgba(0,0,0,0.45), 0 0 32px rgba(199,125,255,0.18), 0 0 80px rgba(125,225,255,0.12) }
    }

    @media (prefers-reduced-motion: reduce){
      *{ animation: none !important; transition: none !important }
    }
  </style>
</head>
<body>

  <!-- 载入：浓雾完全覆盖，数据就绪后散开并移除 -->
  <div class="veil" id="veil" aria-hidden="true">
    <div class="fog l"></div>
    <div class="fog r"></div>
  </div>

  <!-- 抽题：全屏眩晕特效容器（隐藏，触发时显示） -->
  <div class="vortex" id="vortex" aria-hidden="true"></div>

  <!-- 更隐蔽返回 -->
  <a class="home" href="index.html" aria-label="返回主页">
    <i class="arrow" aria-hidden="true"></i>
    <span class="sr-only">返回</span>
  </a>

  <!-- 舞台 -->
  <main class="stage" aria-live="polite">
    <article class="card" id="card">
      <div class="q dim" id="q">触碰符印，命运会揭示一个问题或挑战。</div>
    </article>
  </main>

  <!-- 符印按钮 -->
  <div class="sigil-wrap">
    <button class="sigil" id="sigil" aria-label="抽取命运">
      <svg viewBox="0 0 100 100" aria-hidden="true">
        <defs>
          <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0%" stop-color="#C77DFF"/>
            <stop offset="100%" stop-color="#7DE1FF"/>
          </linearGradient>
        </defs>
        <circle cx="50" cy="50" r="34" fill="none" stroke="url(#g)" stroke-width="1.5" class="ring"/>
        <circle cx="50" cy="50" r="26" fill="none" stroke="url(#g)" stroke-width="0.8" opacity="0.55"/>
        <path d="M50 28 L56 50 L50 72 L44 50 Z" fill="none" stroke="url(#g)" stroke-width="0.8" opacity="0.45"/>
      </svg>
    </button>
  </div>

  <!-- 业务脚本（模块化，直连 Firebase Realtime Database） -->
  <script type="module">
    // —— Firebase —— //
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-analytics.js";
    import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAu6RnEXYMRsJP3Q8EISNyQRPtbGLDYwkk",
      authDomain: "truth-or-dare-b4b2a.firebaseapp.com",
      databaseURL: "https://truth-or-dare-b4b2a-default-rtdb.firebaseio.com",
      projectId: "truth-or-dare-b4b2a",
      storageBucket: "truth-or-dare-b4b2a.firebasestorage.app",
      messagingSenderId: "643326186626",
      appId: "1:643326186626:web:861df5ec9c5ca8e669d09b",
      measurementId: "G-5TXR8Y8BSR"
    };

    const app = initializeApp(firebaseConfig);
    try { getAnalytics(app); } catch {}

    const db = getDatabase(app);

    // —— DOM 快捷 —— //
    const $ = (s, p=document) => p.querySelector(s);
    const veil = $('#veil');
    const vortex = $('#vortex');
    const qEl = $('#q');
    const cardEl = $('#card');
    const sigilEl = $('#sigil');

    // —— 小工具 —— //
    const vibe = (pattern) => { try{ navigator.vibrate && navigator.vibrate(pattern); }catch{} };
    const randIndex = (len) => {
      if (crypto?.getRandomValues) { const a = new Uint32Array(1); crypto.getRandomValues(a); return a[0] % len; }
      return Math.floor(Math.random()*len);
    };
    const glyphs = "卍✶✧◦◯◬◩◇◆▷◈▵▿※*•·~^˙˖";

    function revealText(el, finalText, duration = 1600){
      const start = performance.now();
      const chars = [...finalText];
      const blank = chars.map(ch => (/\s/.test(ch) ? " " : ""));
      const tick = (t) => {
        const p = Math.min(1, (t - start) / duration);
        const count = Math.floor(p * chars.length);
        let out = "";
        for (let i=0; i<chars.length; i++){
          if (i < count) out += chars[i];
          else out += (blank[i] === " " ? " " : glyphs[randIndex(glyphs.length)]);
        }
        el.textContent = out;
        el.style.filter = `blur(${(1-p)*3}px)`;
        el.style.opacity = String(0.8 + 0.2*p);
        if (p < 1) requestAnimationFrame(tick);
        else { el.textContent = finalText; el.style.filter = 'blur(0px)'; el.style.opacity = '1'; }
      };
      requestAnimationFrame(tick);
    }

    // —— 数据拉取与扁平 —— //
    async function fetchCategory(path){
      const snap = await get(ref(db, path));
      if (!snap.exists()) return [];
      const val = snap.val();
      if (Array.isArray(val)) return val.filter(Boolean).map(s => String(s).trim()).filter(Boolean);
      const out = [];
      for (const k of Object.keys(val || {})){
        const node = val[k];
        if (Array.isArray(node)) out.push(...node);
        else if (node && typeof node === 'object'){
          for (const kk of Object.keys(node)) if (Array.isArray(node[kk])) out.push(...node[kk]);
        }
      }
      return out.map(s => String(s).trim()).filter(Boolean);
    }

    async function loadData(){
      const [truth, dare] = await Promise.all([ fetchCategory('/truth'), fetchCategory('/dare') ]);
      const truthU = [...new Set(truth)];
      const dareU = [...new Set(dare)];
      return { truth: truthU, dare: dareU, all: [...new Set([...truthU, ...dareU])] };
    }

    // —— 载入帷幕：数据就绪后散开并移除（页面不再出现任何雾层） —— //
    let DATA = { truth: [], dare: [], all: [] };
    const mode = new URLSearchParams(location.search).get('mode')?.toLowerCase();
    const MODE = (mode === 'truth' || mode === 'dare') ? mode : 'all';

    const dataReady = (async () => {
      try { DATA = await loadData(); }
      catch(e){ console.warn('数据加载失败：', e); }
    })();

    (async () => {
      const minWait = new Promise(res => setTimeout(res, 1200)); // 保留一点期待
      const maxWait = new Promise(res => setTimeout(res, 2600));
      await minWait;
      await Promise.race([dataReady, maxWait]);
      veil.classList.add('disperse');
      setTimeout(()=> veil.remove(), 1900);
      setTimeout(()=> { cardEl.classList.add('glow'); setTimeout(()=> cardEl.classList.remove('glow'), 1100); }, 600);
    })();

    // —— 使用记录（避免重复） —— //
    function storageKey(m){ return `fate.used.${m}`; }
    function getUsed(m){
      try { return new Set(JSON.parse(sessionStorage.getItem(storageKey(m)) || "[]")); }
      catch { return new Set(); }
    }
    function setUsed(m, s){ sessionStorage.setItem(storageKey(m), JSON.stringify([...s])); }

    function pickFromPool(){
      const pool = DATA[MODE] || [];
      if (!pool.length) return null;
      const used = getUsed(MODE);
      if (used.size >= pool.length - 1){ setUsed(MODE, new Set()); used.clear(); }
      const candidates = pool.filter(x => !used.has(x));
      const choice = (candidates.length ? candidates : pool)[randIndex(candidates.length || pool.length)];
      used.add(choice); setUsed(MODE, used);
      return choice;
    }

    // —— 抽题：全屏眩晕 + 3 秒延迟 —— //
    const DELAY_MS = 3000;

    function runVortex(){
      vortex.classList.remove('show'); void vortex.offsetWidth; // 重新触发
      vortex.classList.add('show');
      vortex.setAttribute('aria-hidden', 'false');
      // 结束后让屏幕回归清透
      setTimeout(() => {
        vortex.classList.remove('show');
        vortex.setAttribute('aria-hidden', 'true');
      }, DELAY_MS);
    }

    function draw(){
      const choice = pickFromPool();
      if (!choice){
        qEl.textContent = '题库还没就位，稍后再触碰我。';
        return;
      }

      sigilEl.classList.add('loading');
      qEl.classList.add('obscured');
      vibe([18, 90, 18]);

      runVortex();

      setTimeout(() => {
        vibe([1, 45, 26, 50, 10]);
        cardEl.classList.remove('tremor','glow'); void cardEl.offsetWidth;
        cardEl.classList.add('tremor','glow');
        revealText(qEl, choice, 1700);
        qEl.classList.remove('obscured');

        setTimeout(()=> sigilEl.classList.remove('loading'), 520);
      }, DELAY_MS);
    }

    sigilEl.addEventListener('click', draw, { passive: true });

    // 双击屏幕也可触发
    let lastTap = 0;
    window.addEventListener('touchend', () => {
      const now = Date.now();
      if (now - lastTap < 360) draw();
      lastTap = now;
    }, { passive: true });

    // 数据失败的温柔降级
    dataReady.finally(() => {
      if (!(DATA[MODE] && DATA[MODE].length)) {
        qEl.textContent = '题库似乎还在路上，点符印再试一次。';
      }
    });
  </script>
</body>
</html>
